#!/bin/sh

# merge_overlay   - recreate 'mods' squashfs

# Author: Michael Towers <gradgrind[at]online[dot]de>
#
# This file is part of the larch project.
#
#    larch is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    larch is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with larch; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#----------------------------------------------------------------------------
# 2008.03.01

# test if the script is started by root user. If not, exit
if [ $UID -ne 0 ]; then
    echo "Only root can run ${APP}"; exit 1
fi

# Underlying system:        /.livesys/system
# 'mods' layer:             /.livesys/mods
# Overlay:                  /.livesys/overlay

# The overlay device (where the archives will be saved)
if [ -d "$1" ]; then
    overlaypath="$1"
else
    echo "ERROR: invalid directory ($1)"
    exit 1
fi

utype="$( cat /.livesys/utype )"
if [ "${utype}" = "unionfs" ]; then
    sqfmnt="ro"
    ovlmnt="ro"
    ovl2mnt="ro"
    bropt="dirs="
    opq=".wh.__dir_opaque"
    whlink="???"
    echo "Overlay merging is currently not implemented for unionfs"
    exit 1
else
    if [ "${utype}" != "aufs" ]; then
        echo "ERROR: bad union type (${utype}), trying aufs"
        utype="aufs"
    fi
    sqfmnt="rr"
    ovlmnt="rr+wh"
    ovl2mnt="ro+wh"
    bropt="br:"
    opq=".wh..wh..opq"
    whlink=".wh.wh.aufs"
fi

if [ -f ${overlaypath}/larch/merge-adjust ] ; then
    . ${overlaypath}/larch/merge-adjust
fi

# Make a directory for a merged union, and one for rebuilding whiteouts
merge_union=/.livesys/merge_union
whiteouts=/.livesys/whiteouts
rm -rf ${merge_union}
mkdir -p ${merge_union}
rm -rf ${whiteouts}
mkdir -p ${whiteouts}

layers="/.livesys/overlay=${ovl2mnt}:/.livesys/mods=${ovlmnt}"
mount -t ${utype} -o ${bropt}${layers} ${utype} ${merge_union}

echo "creating mods.sqf_"
# Note that 'etc' is not included - mods.sqf has no /etc directory.
savedirs="bin boot home lib mnt opt root sbin srv usr"
#NB: var probably has to be handled separately because of the excludes.

:>${whiteouts}/${whlink}
#?
chmod 444 ${whiteouts}/${whlink}
cd "${whiteouts}"

# mkwhite will check that all leading directories exist in the whiteout
# tree, creating them with attributes from merge_union if necessary.

mkdirs ()
{
    echo "mkdirs $1"
    local d0
    d0="$1"
    if [ ! -d "${d0}" ]; then
        mkdirs "$( dirname "${d0}" )"
        mkdir "${d0}"
        chmod "${d0}" --reference="${merge_union}/${d0}"
        chown "${d0}" --reference="${merge_union}/${d0}"
        touch "${d0}" --reference="${merge_union}/${d0}"
    fi
}

mkwhite ()
{
    if [ ! -d "$1" ]; then
        mkdirs "$1"
    fi

    ln "${whlink}" "$1/$2"
}

echo "   1) Find whiteouts"
for d in ${savedirs} var; do
    if [ ! -d "${merge_union}/${d}" ]; then continue; fi

# Walk through the directories in merge_union, looking for whiteouts,
# first in overlay, then in mods. Be aware that those in mods might be
# affected by the contents of overlay.
    find "${merge_union}/${d}" -type d -print '%P\n' | while read td; do

        skipmods=""
        find "/.livesys/overlay/${d}" -maxdepth 1 -regex '\.wh\.[^/]*' \
                -type f -print '%P\n' | while read fw; do

            if [ "${fw}" = "${opq}" ]; then
                if [ -d "/.livesys/system/${d}" ]; then
                    mkwhite "${d}" "${opq}"
                fi
                # Don't investigate this directory in mods
                skipmods="y"
            else
                f="${fw#\.wh\.}"
                if [ -e "/.livesys/system/${d}/${f}" ]; then
                    mkwhite "${d}" "${fw}"
                fi
            fi

        done

        if [ -n "${skipmods}" ]; then continue; fi

        find "/.livesys/mods/${dp}" -maxdepth 1 -regex '\.wh\.[^/]*' \
                -type f -print '%P\n' | while read fw; do

            if [ "${fw}" = "${opq}" ]; then
                if [ -d "/.livesys/system/${d}" ]; then
                    mkwhite "${d}" "${opq}"
                fi
            else
                f="${fw#\.wh\.}"
                if [ -e "/.livesys/system/${d}/${f}" ] && \
                        [ ! -e "/.livesys/overlay/${d}/${f}" ]; then
                    mkwhite "${d}" "${fw}"
                fi
            fi

        done

    done

done

echo "   2) Build mods.tmp, just files, no whiteouts"
cd "${merge_union}"
# root directories which are not included in mods.sqf
ignoredirs="dev etc media proc sys tmp .larch .livesys"
# non-included /var directories
vardirs="var/log var/tmp var/cache/pacman/pkg"
mksquashfs ${savedirs} "${overlaypath}/mods.tmp" -e ${ignoredirs} ${vardirs}
if [ $? -ne 0 ]; then
    echo "ERROR: Couldn't create ${overlaypath}/mods.tmp"
    rm -f "${overlaypath}/mods.tmp"
    exit 1
fi

echo "   3) Extend mods.tmp with whiteouts"
for d in ${vardirs}; do
    if [ -d "${whiteouts}/${d}" ]; then
        rm -r "${whiteouts}/${d}"
    fi
done
mksquashfs "${whiteouts}" "${overlaypath}/mods.tmp"
if [ $? -ne 0 ]; then
    echo "ERROR: Couldn't extend ${overlaypath}/mods.tmp"
    rm -f "${overlaypath}/mods.tmp"
    exit 1
fi

# Discard whiteouts
rm -rf "${whiteouts}"

# Discard merge union
cd /
umount ${merge_union}

echo "creating overlay.ovl_"
# Compress the overlay (with root dir 'overlay' retained)
tar -cf - -C /.livesys overlay/etc | lzop > ${overlaypath}/overlay.ovl_
if [ $? -ne 0 ]; then
    echo "ERROR: couldn't create ${overlaypath}/overlay.ovl_"
    rm -f ${overlaypath}/overlay.ovl_
    exit 1
fi

echo "renaming mods.tmp to mods.sqf_"
mv "${overlaypath}/mods.tmp" "${overlaypath}/mods.sqf_"
echo "merging finished"

exit 0
